package main

import (
	"bufio"
	"fmt"
	"os"
	"regexp"
	"strings"
)

/*
-- ПРИНЦИП РАБОТЫ --
  Алгоритм топологической сортировки графа зависимостей основан на использовании алгоритма поиска в ширину (BFS).
  Мы начинаем с узлов, у которых нет входящих ребер (то есть степень входа равна 0) и постепенно добавляем их в порядке,
  который гарантирует корректное удовлетворение всех зависимостей.
  Для каждого узла мы уменьшаем счетчик его зависимостей и добавляем в очередь все узлы, которые теперь имеют нулевую степень входа.
  Процесс повторяется до тех пор, пока очередь не опустеет.

-- РЕАЛИЗАЦИЯ --
  Мы начинаем с построения карты зависимостей, используя регулярное выражение для извлечения зависимостей из входных данных.
  Затем мы вычисляем степень входа для каждого узла и начинаем топологическую сортировку с узлов, у которых степень входа равна 0.
  Результат сохраняется в порядке, который гарантирует установку пакетов в правильной последовательности.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
  Корректность алгоритма обеспечивается проверкой всех зависимостей каждого узла перед его добавлением в результат.
  При правильном вычислении степени входа и последовательной обработке узлов мы гарантируем, что каждая зависимость удовлетворена,
  что делает порядок установки корректным.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
  Временная сложность алгоритма зависит от числа узлов и ребер в графе зависимостей.
  Построение карты зависимостей занимает O(n), где n - количество строк во входных данных.
  Топологическая сортировка занимает O(n + m), где n - количество узлов, m - количество ребер, что обычно считается эффективным для подобных задач.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
  Пространственная сложность алгоритма зависит от объема входных данных и структур данных, используемых для хранения графа и его зависимостей.
  В данном случае она ограничена размером карты зависимостей и степенями входа узлов.
*/

// Читает входные данные из файла "input.txt"
func getInputData() []string {
	input, _ := os.Open("input.txt") // Открываем файл input.txt
	defer input.Close()              // Закрываем файл в конце функции

	const maxCapacity = 10240 * 1024 // Максимальная ёмкость буфера для сканера
	buf := make([]byte, maxCapacity) // Создаём буфер для сканера

	scanner := bufio.NewScanner(input) // Создаём сканер для чтения файла
	scanner.Split(bufio.ScanLines)     // Устанавливаем сканеру разделение по строкам
	scanner.Buffer(buf, maxCapacity)   // Устанавливаем буфер для сканера

	var s []string // Создаём пустой срез для хранения строк

	for scanner.Scan() { // Построчно сканируем файл
		bufStr := scanner.Text() // Читаем строку из сканера
		s = append(s, bufStr)    // Добавляем строку в срез
	}

	return s // Возвращаем срез с прочитанными строками
}

// Разбирает зависимости из входных данных и строит граф зависимостей
func parseDependencies(lines []string) map[string][]string {
	dependencies := make(map[string][]string)              // Создаём карту зависимостей
	re := regexp.MustCompile(`"([^"]+)"\s*->\s*"([^"]+)"`) // Компилируем регулярное выражение для поиска зависимостей

	for _, line := range lines { // Перебираем строки входных данных
		if strings.Contains(line, "->") { // Если строка содержит "->", значит, это строка с зависимостью
			matches := re.FindStringSubmatch(line) // Ищем совпадения с регулярным выражением
			if len(matches) == 3 {                 // Если найдены два совпадения (from и to)
				from := matches[1]                                  // Получаем имя узла, от которого идёт зависимость
				to := matches[2]                                    // Получаем имя узла, на который идёт зависимость
				dependencies[from] = append(dependencies[from], to) // Добавляем зависимость в карту
				// Убедимся, что все пакеты присутствуют в графе
				if _, exists := dependencies[to]; !exists {
					dependencies[to] = []string{} // Если узел отсутствует, создаём пустой срез
				}
			}
		}
	}

	return dependencies // Возвращаем построенную карту зависимостей
}

// Выполняет топологическую сортировку графа зависимостей
func topologicalSort(dependencies map[string][]string) ([]string, error) {
	inDegree := make(map[string]int) // Создаём карту для хранения степеней входа узлов
	for node := range dependencies { // Для каждого узла в графе
		if _, exists := inDegree[node]; !exists {
			inDegree[node] = 0 // Инициализируем степень входа нулём, если узел ещё не инициализирован
		}
	}
	for _, deps := range dependencies { // Для каждого узла в графе
		for _, dep := range deps { // Для каждой зависимости узла
			inDegree[dep]++ // Увеличиваем степень входа узла, на который указывает зависимость
		}
	}

	queue := make([]string, 0)       // Создаём очередь для узлов с нулевой степенью входа
	for node := range dependencies { // Для каждого узла в графе
		if inDegree[node] == 0 { // Если у узла степень входа равна нулю
			queue = append(queue, node) // Добавляем узел в очередь
		}
	}

	var sorted []string // Создаём пустой срез для хранения упорядоченного списка узлов

	for len(queue) > 0 { // Пока очередь не пуста
		node := queue[0]  // Извлекаем первый узел из очереди
		queue = queue[1:] // Удаляем из очереди первый узел

		sorted = append(sorted, node) // Добавляем узел в конец упорядоченного списка

		for _, dep := range dependencies[node] { // Для каждого узла, зависимого от текущего узла
			inDegree[dep]--         // Уменьшаем степень входа
			if inDegree[dep] == 0 { // Если степень входа стала равна нулю
				queue = append(queue, dep) // Добавляем узел в очередь
			}
		}
	}

	if len(sorted) != len(dependencies) { // Если размер упорядоченного списка не равен числу узлов в графе
		return nil, fmt.Errorf("cyclic dependency detected") // Возвращаем ошибку - обнаружен цикл в зависимостях
	}

	// Разворачиваем список, чтобы получить пакеты в обратном порядке
	for i, j := 0, len(sorted)-1; i < j; i, j = i+1, j-1 {
		sorted[i], sorted[j] = sorted[j], sorted[i]
	}

	return sorted, nil // Возвращаем упорядоченный список узлов
}

func main() {
	lines := getInputData()                  // Читаем входные данные из файла
	dependencies := parseDependencies(lines) // Разбираем зависимости из входных данных

	order, err := topologicalSort(dependencies) // Выполняем топологическую сортировку зависимостей
	if err != nil {                             // Если произошла ошибка в сортировке
		fmt.Printf("Error in topological sort: %v\n", err) // Выводим сообщение об ошибке
		return
	}

	for _, pkg := range order { // Для каждого упорядоченного узла
		fmt.Println(pkg) // Выводим его на экран
	}
}
