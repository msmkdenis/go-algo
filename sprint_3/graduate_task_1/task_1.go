package main

func brokenSearch(arr []int, k int) int {
	start := 0
	end := len(arr) - 1

	// Пока начальный индекс меньше или равен конечному
	for start <= end {
		mid := start + (end-start)/2 // Избегаем переполнения

		// Если нашли элемент, возвращаем его индекс
		if arr[mid] == k {
			return mid
		}

		// Определяем, отсортирована ли левая часть
		if arr[start] <= arr[mid] {
			// Если элемент находится в отсортированной левой части
			if k >= arr[start] && k < arr[mid] {
				end = mid - 1
			} else {
				start = mid + 1
			}
		} else {
			// Если элемент находится в отсортированной правой части
			if k > arr[mid] && k <= arr[end] {
				start = mid + 1
			} else {
				end = mid - 1
			}
		}
	}
	// Если элемент не найден, возвращаем -1
	return -1
}

func test() {
	arr := []int{5, 1}
	if brokenSearch(arr, 1) != 1 {
		panic("WA")
	}
}

/*
В этом алгоритме мы добавили проверку, чтобы определить, является ли левая часть от start до mid отсортированной.
Если это так, мы проверяем, находится ли искомый элемент k в этом диапазоне.
Если он находится в отсортированной части, мы сужаем поиск до этой части.
В противном случае, мы ищем в другой части массива.

Этот алгоритм позволяет эффективно работать со сломанными массивами, сохраняя при этом преимущества бинарного поиска с временем выполнения
*/
