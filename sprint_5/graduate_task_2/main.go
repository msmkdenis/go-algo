package main

// https://contest.yandex.ru/contest/24810/run-report/108690954/

/*
-- ПРИНЦИП РАБОТЫ --
  Для удаления вершины бинарного дерева поиска по ключу необходимо выполнить две операции:
  1. Найти вершину
  2. Корректно удалить вершину, сохраняя целостность дерева

-- РЕАЛИЗАЦИЯ --
  Сначала найдем удаляемую вершину
  	- если искомое значение меньше значения вершины - рекурсивно удаляем в левом поддереве
  	- если искомое значение больше значения вершины - рекурсивно удаляем в правом поддереве

  После того как мы найдем вершину для удаления возможны варианты:
  	- у удаляемой вершины нет левого и правого потомков:
		удаляем элемент, дерево остается валидным

  	- у удаляемой вершины есть только левый потомок:
		назначим потомком текущего элемента левое поддерево

  	- у удаляемой вершины есть только правое поддерево
		назначим потомком текущего элемента правое поддерево

  	- у удаляемой вершины есть и левое поддерево и правое поддерево
		заменим искомый элемент подходящим элементом среди потомков
		подходящим будем считать максимальный элемент в левом поддереве
		после замены у нас получается копия элемента в левом поддереве
		мы можем рекурсивно удалить этот элемент, и алгоритм остановится
		либо на первом, либо на втором варианте выше

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
  Корректность обеспечивается устройством бинарного дерева поиска:
  - для каждой вершины Х бинарного дерева поиска обязательно выполняется условие:
		в левом поддереве вершины со значениями меньше Х
		в правом поддереве вершины со значениями больше Х
  - вершина в левом поддереве относительно любого Х с максимальным значением:
		всегда имеет значение менее Х
		всем имеет значение больше любого значения вершин в левом поддереве относительно Х
		никогда не имеет потомков в правом поддереве

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
  Алгоритм выполняется за O(H), где H - высота дерева.
  При поиске удаляемого значения мы рекурсивно спускаемся по дереву максимально на К шагов.
  При необходимости мы ищем в левом поддереве вершину с максимальным значением, также рекурсивно максимально на Т шагов.
  При этом сумма К и Т не может быть больше Н - высоты дерева.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
  Дополнительная память потребуется на хранения стэка вызовов, который может составить до Н.
*/

type Node struct {
	value int
	left  *Node
	right *Node
}

func remove(node *Node, key int) *Node {
	if node == nil {
		return node
	}

	if key > node.value {
		node.right = remove(node.right, key)
		return node
	}

	if key < node.value {
		node.left = remove(node.left, key)
		return node
	}

	if node.left == nil && node.right == nil {
		return nil
	}

	if node.left == nil {
		node = node.right
		return node
	}

	if node.right == nil {
		node = node.left
		return node
	}

	replacementNode := findLeftMaxNode(node.left)
	node.value = replacementNode.value

	node.left = remove(node.left, replacementNode.value)

	return node
}

func findLeftMaxNode(node *Node) *Node {
	for node.right != nil {
		node = node.right
	}
	return node
}
