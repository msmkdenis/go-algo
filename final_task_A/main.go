package main

import (
	"bufio"
	"fmt"
	"os"
)

// https://contest.yandex.ru/contest/25597/run-report/112309234/

/*
-- ПРИНЦИП РАБОТЫ --
  Алгоритм нахождения расстояния Левенштейна между двумя строками s и t основан на динамическом программировании.
  Используем два одномерных массива для хранения промежуточных результатов.
  Каждый элемент массива curr[j] содержит расстояние Левенштейна для подстрок s[:i] и t[:j-1],
  где i - текущая позиция в строке s, а j - текущая позиция в строке t.
  Алгоритм заполняет массивы curr и prev пошагово, начиная с пустых строк
  и постепенно увеличивая размеры подстрок до полных строк s и t.
  При этом используются три основных операции: вставка, удаление и замена символов.

-- РЕАЛИЗАЦИЯ --
  Создаем два одномерных массива размером (m+1) для хранения расстояний Левенштейна.

  prev[j] будет содержать расстояние Левенштейна для подстрок s[:i-1] и t[:j],
  где i - предыдущая позиция в строке s, а j - текущая позиция в строке t.

  curr[j] будет содержать расстояние Левенштейна для подстрок s[:i] и t[:j-1],
  где i - текущая позиция в строке s, а j - текущая позиция в строке t.

  Инициализируем значения в prev для первой строки и в curr для первого элемента.

  Если текущие символы в строках s и t совпадают, то расстояние Левенштейна не изменяется.
  В противном случае, берем минимум из трех возможных операций: вставки, удаления и замены, используя значения из prev:

  	prev[j] представляет расстояние Левенштейна между подстрокой s[:i-1] и строкой t[:j].
  	Это значение соответствует операции удаления, потому что мы удаляем символ из строки s.

  	prev[j-1] представляет расстояние Левенштейна между подстрокой s[:i-1] и строкой t[:j-1].
  	Это значение соответствует операции замены, потому что мы заменяем символ в строке s на символ из строки t.

  	curr[j-1] представляет расстояние Левенштейна между подстрокой s[:i] и строкой t[:j-1].
  	Это значение соответствует операции вставки, потому что мы вставляем символ в строку s.

  Расстояние Левенштейна для всей строки s и t находится в последнем элементе массива curr.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
  Временная сложность алгоритма определяется длинами строк s и t и составляет O(n*m),
  где n и m - длины строк s и t соответственно.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
  Пространственная сложность алгоритма определяется длинами строк s и t и составляет O(min(n, m)),
  где n и m - длины строк s и t соответственно.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
  Алгоритм находит оптимальное расстояние Левенштейна между двумя строками, используя систематическое исследование
  всех возможных путей преобразования одной строки в другую.
  Так как на каждом шаге алгоритм выбирает наименьшее значение из трех возможных операций (вставка, удаление, замена),
  он гарантированно находит минимальное количество операций, необходимых для преобразования одной строки в другую.
*/

func main() {
	input := getInputData()
	s := input[0]
	t := input[1]

	fmt.Println(LevenshteinDistance(s, t))
}

func LevenshteinDistance(s, t string) int {
	n, m := len(s), len(t)

	// Создаем два одномерных массива для хранения значений dp.
	prev := make([]int, m+1)
	curr := make([]int, m+1)

	for j := 0; j <= m; j++ {
		prev[j] = j
	}

	for i := 1; i <= n; i++ {
		curr[0] = i
		for j := 1; j <= m; j++ {
			if s[i-1] == t[j-1] {
				curr[j] = prev[j-1]
			} else {
				curr[j] = 1 + minOperation(prev[j], curr[j-1], prev[j-1])
			}
		}
		// Обновляем массив prev для следующей итерации.
		copy(prev, curr)
	}

	// Расстояние Левенштейна для всей строки s и t находится в последнем элементе массива curr.
	return curr[m]
}

func minOperation(a, b, c int) int {
	minVal := a
	if b < minVal {
		minVal = b
	}
	if c < minVal {
		minVal = c
	}
	return minVal
}

func getInputData() []string {
	input, _ := os.Open("input.txt")
	defer input.Close()

	const maxCapacity = 10240 * 1024
	buf := make([]byte, maxCapacity)

	scanner := bufio.NewScanner(input)
	scanner.Split(bufio.ScanLines)
	scanner.Buffer(buf, maxCapacity)

	var s []string
	for scanner.Scan() {
		bufStr := scanner.Text()
		s = append(s, bufStr)
	}

	return s
}
