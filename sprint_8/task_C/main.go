package main

import (
	"bufio"
	"fmt"
	"os"
	"strings"
)

/*
-- ПРИНЦИП РАБОТЫ --
  Алгоритм находит палиндром максимальной длины и минимальной лексикографической последовательности,
  используя подсчет частот символов в строке. Мы строим первую половину палиндрома, используя частоты символов.
  Затем добавляем центральный символ (если необходимо) и формируем вторую половину, отражая первую.

-- РЕАЛИЗАЦИЯ --
  Считываем строку s.
  Инициализируем массив hash размером 26, где каждому символу алфавита соответствует его частота в строке s.
  Создаем переменные для хранения центрального символа и первой половины палиндрома.
  Проходим по массиву hash, формируем первую половину палиндрома, добавляя к ней каждый символ, встречающийся четное количество раз.
  Если длина строки нечетная, определяем центральный символ палиндрома.
  Формируем вторую половину палиндрома, отражая первую.
  Объединяем первую и вторую половины палиндрома и возвращаем результат.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
  Максимальная длина палиндрома: Мы строим палиндром, используя символы, встречающиеся четное количество раз, что позволяет нам максимизировать длину палиндрома.
  Лексикографически минимальный палиндром: Построение палиндрома начинается с самых маленьких символов, что гарантирует минимальность палиндрома в лексикографическом порядке.
  Уникальность: Каждая итерация цикла добавляет только один символ к палиндрому, что гарантирует единственность результата.
  Отражение: Формирование второй половины палиндрома путем отражения первой гарантирует, что палиндром симметричен относительно своего центра.
  Корректность центрального символа: Если длина строки нечетная, мы правильно определяем центральный символ палиндрома.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
  Временная сложность алгоритма определяется длиной строки s и составляет O(n), где n - длина строки s.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
  Пространственная сложность алгоритма зависит от размера алфавита (в данном случае 26) и составляет O(1), так как массив hash имеет фиксированный размер.
*/

func main() {
	input := getInputData()
	s := input[0]
	fmt.Print(getPalindrome(s))
}

func getPalindrome(s string) string {
	// Массив для подсчета частот символов
	hash := [26]int{}

	// Подсчет частот символов в строке s
	for _, char := range s {
		hash[char-97]++
	}

	// Переменная для хранения первой половины палиндрома
	var result strings.Builder

	// Формирование первой половины палиндрома
	for char, count := range hash {
		for i := 0; i < count/2; i++ {
			result.WriteByte(byte(char + 97))
			hash[char] -= 2
		}
	}

	// Если строка имеет четную длину, определяем центральный символ палиндрома
	if result.Len() == 0 {
		for char, count := range hash {
			if count > 0 {
				return string(byte(char + 97))
			}
		}
	}

	// Проверка, нужно ли добавить центральный символ палиндрома
	halvesIntersect := false
	if len(s)%2 == 0 {
		for char, count := range hash {
			if count > 0 {
				result.WriteByte(byte(char) + 97)
				halvesIntersect = true
				break
			}
		}
	}

	// Формирование второй половины палиндрома путем отражения первой
	firstHalf := result.String()
	var secondHalf strings.Builder
	lastIdx := len(firstHalf) - 1
	if halvesIntersect {
		lastIdx--
	}
	for i := lastIdx; i >= 0; i-- {
		secondHalf.WriteByte(firstHalf[i])
	}
	return firstHalf + secondHalf.String()
}
func getInputData() []string {
	input, _ := os.Open("input.txt")
	defer input.Close()

	const maxCapacity = 10240 * 1024
	buf := make([]byte, maxCapacity)

	scanner := bufio.NewScanner(input)
	scanner.Split(bufio.ScanLines)
	scanner.Buffer(buf, maxCapacity)

	var s []string
	for scanner.Scan() {
		bufStr := scanner.Text()
		s = append(s, bufStr)
	}

	return s
}
