package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
)

/*
Принцип работы:

1. Нам нужно определить, можно ли разделить сумму всех заработанных очков на две части так, чтобы они были равными.
2. Для этого мы используем динамическое программирование.
3. Сначала проверяем, является ли общая сумма всех очков четным числом. Если нет, тогда разделение на две равные части невозможно, и мы возвращаем `false`.
4. Затем мы создаем массив `dp`, где `dp[i]` будет равно `true`, если сумма очков `i` может быть достигнута, и `false` в противном случае.
5. Мы пробегаем по всем заработанным очкам и для каждого очка обновляем значения массива `dp`. Если мы можем достичь суммы `j` с использованием очка `score`, тогда `dp[j]` устанавливается в `true`.
6. В конце, если `dp[target]` равно `true`, где `target` - это половина общей суммы, то это означает, что можно разделить очки на две равные части.

Реализация по шагам:

1. Проверяем четность общей суммы. Если сумма нечетная, возвращаем `false`.
2. Создаем массив `dp` размером `(total/2) + 1`, где `total` - это сумма всех очков.
3. Устанавливаем `dp[0]` в `true`, так как можно достигнуть нулевую сумму без использования каких-либо очков.
4. Проходимся по всем заработанным очкам. Для каждого очка:
   - Проходимся от `target` до `score`.
   - Обновляем значения `dp[j]` как `dp[j] || dp[j-score]`.
5. Возвращаем `dp[target]`.

Доказательство корректности:

Доказательство корректности основывается на том, что мы используем динамическое программирование для проверки всех возможных сумм очков, которые можно достичь. Если мы можем достичь половину общей суммы с использованием всех заработанных очков, то это означает, что можно разделить очки на две равные части.

Временная сложность:

Пусть `n` - количество выигранных партий, а `total` - сумма всех очков.

Временная сложность алгоритма составляет `O(n * total)`, так как мы проходимся по всем заработанным очкам и для каждого очка обновляем значения массива `dp`.

Пространственная сложность:

Пространственная сложность алгоритма составляет `O(total)`, так как мы используем массив `dp` размером `(total/2) + 1` для хранения промежуточных результатов.
*/

// Функция для проверки возможности разбиения очков на две части
func canSplitScores(scores []int) bool {
	total := 0
	for _, score := range scores {
		total += score
	}

	// Если сумма очков нечётная, невозможно разбить на две части с одинаковой суммой
	if total%2 != 0 {
		return false
	}

	target := total / 2

	// Используем динамическое программирование для определения возможности разбиения
	dp := make([]bool, target+1)
	dp[0] = true

	for _, score := range scores {
		for j := target; j >= score; j-- {
			dp[j] = dp[j] || dp[j-score]
		}
	}

	return dp[target]
}

// Функция для чтения входных данных из файла
func getInputData() []string {
	input, _ := os.Open("input.txt")
	defer input.Close()

	const maxCapacity = 10240 * 1024
	buf := make([]byte, maxCapacity)

	scanner := bufio.NewScanner(input)
	scanner.Split(bufio.ScanLines)
	scanner.Buffer(buf, maxCapacity)

	var s []string
	for scanner.Scan() {
		bufStr := scanner.Text()
		s = append(s, bufStr)
	}

	return s
}

func main() {
	lines := getInputData()

	n, _ := strconv.Atoi(lines[0])
	scoreStr := strings.Fields(lines[1])

	scores := make([]int, n)
	for i := 0; i < n; i++ {
		score, _ := strconv.Atoi(scoreStr[i])
		scores[i] = score
	}

	possible := canSplitScores(scores)
	if possible {
		fmt.Println("True")
	} else {
		fmt.Println("False")
	}
}
