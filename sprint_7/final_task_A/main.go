package main

import (
	"bufio"
	"fmt"
	"os"
)

// https://contest.yandex.ru/contest/25597/run-report/112872741/

/*
-- ПРИНЦИП РАБОТЫ --
  Алгоритм нахождения расстояния Левенштейна между двумя строками s и t основан на динамическом программировании.
  Мы создаем одномерный массив dp размером (n+1), где n - длина более короткой строки s или t.
  Этот массив используется для хранения промежуточных результатов и значений расстояния Левенштейна.
  Значение dp[i] представляет расстояние Левенштейна между подстроками s[:i] и t до текущей позиции j,
  где i - текущая позиция в строке s, а j - текущая позиция в строке t.

-- РЕАЛИЗАЦИЯ --
  Создаем одномерный массив dp размером (n+1), где n - длина более короткой строки s или t.
  Этот массив используется для хранения промежуточных результатов и значений расстояния Левенштейна.
  Значение dp[i] представляет расстояние Левенштейна между подстроками s[:i] и t до текущей позиции j,
  где i - текущая позиция в строке s, а j - текущая позиция в строке t.

  Инициализируем массив dp начальными значениями от 0 до n.

  Заполняем массив значениями расстояния Левенштейна с помощью вложенных циклов.
  Внешний цикл проходит по строке t, а внутренний - по строке s.
  На каждом шаге алгоритма вычисляется минимальное расстояние Левенштейна для текущей позиции в строке t
  и всех подстрок строки s до текущей позиции.

  После завершения заполнения массива dp, расстояние Левенштейна для всей строки s и t находится в dp[n].

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
  Алгоритм находит оптимальное расстояние Левенштейна между двумя строками, используя систематическое исследование
  всех возможных путей преобразования одной строки в другую.

  На каждом шаге алгоритма выбирается минимальное из трех возможных значений: удаление, вставка или замена символа.
  Это гарантирует нахождение минимального расстояния Левенштейна между строками s и t.

  После завершения работы алгоритма, последнее значение dp[n] содержит итоговое расстояние Левенштейна между строками s и t.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
  Временная сложность алгоритма определяется длинами строк s и t и составляет O(n*m),
  где n и m - длины строк s и t соответственно.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
  Пространственная сложность алгоритма определяется длинами строк s и t и составляет O(min(n, m)),
  где n и m - длины строк s и t соответственно.
*/

func main() {
	input := getInputData()
	s := input[0]
	t := input[1]

	fmt.Println(LevenshteinDistance(s, t))
}

func LevenshteinDistance(s, t string) int {
	n, m := len(s), len(t)
	if n == 0 {
		return m
	}
	if m == 0 {
		return n
	}

	if n > m {
		// Поменяем местами строки и их длины
		n, m = m, n
		s, t = t, s
	}

	// Создаем одномерный массив для хранения результатов
	dp := make([]int, n+1)

	// Инициализируем массив начальными значениями
	for i := 0; i <= n; i++ {
		dp[i] = i
	}

	// Заполняем массив значениями расстояния Левенштейна
	for j := 1; j <= m; j++ {
		prev := dp[0]
		dp[0] = j
		for i := 1; i <= n; i++ {
			temp := dp[i]
			if s[i-1] == t[j-1] {
				dp[i] = prev
			} else {
				dp[i] = 1 + minOperation(prev, dp[i], dp[i-1])
			}
			prev = temp
		}
	}

	// Расстояние Левенштейна для всей строки s и t находится в последнем элементе массива dp.
	return dp[n]
}

func minOperation(a, b, c int) int {
	minVal := a
	if b < minVal {
		minVal = b
	}
	if c < minVal {
		minVal = c
	}
	return minVal
}

func getInputData() []string {
	input, _ := os.Open("input.txt")
	defer input.Close()

	const maxCapacity = 10240 * 1024
	buf := make([]byte, maxCapacity)

	scanner := bufio.NewScanner(input)
	scanner.Split(bufio.ScanLines)
	scanner.Buffer(buf, maxCapacity)

	var s []string
	for scanner.Scan() {
		bufStr := scanner.Text()
		s = append(s, bufStr)
	}

	return s
}
