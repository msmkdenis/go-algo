package main

import (
	"bufio"
	"fmt"
	"os"
)

// https://contest.yandex.ru/contest/25597/run-report/112235750/

/*
-- ПРИНЦИП РАБОТЫ --
  Алгоритм нахождения расстояния Левенштейна между двумя строками s и t основан на динамическом программировании.
  Он использует двумерный массив dp для хранения промежуточных результатов.
  Каждая ячейка dp[i][j] содержит расстояние Левенштейна для подстрок s[:i] и t[:j].
  Алгоритм заполняет этот массив пошагово, начиная с пустых строк и постепенно увеличивая размеры подстрок до полных строк s и t.
  При этом используются три основных операции: вставка, удаление и замена символов.

-- РЕАЛИЗАЦИЯ --
  Создаем двумерный массив размером (n+1) x (m+1) для хранения расстояний Левенштейна.
  dp[i][j] будет содержать расстояние Левенштейна для подстрок s[:i] и t[:j].

  Инициализируем значения в первой строке и первом столбце.

  Если текущие символы в строках s и t совпадают, то расстояние Левенштейна не изменяется.
  В противном случае, берем минимум из трех возможных операций: вставки, удаления и замены:

  	dp[i-1][j] представляет расстояние Левенштейна между подстрокой s[:i-1] и строкой t[:j].
  	Это значение соответствует операции удаления, потому что мы удаляем символ из строки s.

		При выполнении удаления мы удаляем символ из строки s, поэтому длина строки s уменьшается на 1,
		но длина строки t остается неизменной. Чтобы учесть эту операцию, мы рассматриваем расстояние
		Левенштейна между подстроками s[:i-1] и t[:j], потому что наша подстрока t не изменяется,
		а подстрока s уменьшается на один символ. Таким образом, мы увеличиваем расстояние Левенштейна на 1.

  	dp[i][j-1] представляет расстояние Левенштейна между подстрокой s[:i] и строкой t[:j-1].
  	Это значение соответствует операции вставки, потому что мы вставляем символ в строку s.

		При выполнении вставки мы добавляем символ из строки t в строку s.
		Таким образом, мы увеличиваем длину строки s на 1, но длина строки t остается неизменной.
		Чтобы учесть эту операцию в алгоритме, мы рассматриваем расстояние между подстроками s[:i] и t[:j-1],
		потому что наша подстрока s не изменяется, а подстрока t уменьшается на один символ.
		Таким образом, мы увеличиваем расстояние Левенштейна на 1.

  	dp[i-1][j-1] представляет расстояние Левенштейна между подстроками s[:i-1] и t[:j-1].
 	Это значение соответствует операции замены, потому что мы заменяем символ в строке s на символ из строки t.

		При выполнении замены одного символа на другой мы изменяем символ в строке s на символ из строки t.
		Обе длины строк s и t остаются неизменными. Чтобы учесть эту операцию, мы рассматриваем расстояние
		между подстроками s[:i-1] и t[:j-1].

  Расстояние Левенштейна для всей строки s и t находится в "правом нижнем углу" массива dp.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
  Временная сложность алгоритма определяется размером матрицы dp, которая имеет размер (n+1) x (m+1),
  где n и m - длины строк s и t соответственно.
  Соответственно временная сложность составляет O(n*m), где n и m - длины строк s и t.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
  Пространственная сложность алгоритма также определяется размером матрицы dp,
  что также составляет O(n*m), где n и m - длины строк s и t соответственно

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
  Алгоритм находит оптимальное расстояние Левенштейна между двумя строками путем
  систематического исследования всех возможных путей преобразования одной строки в другую.
  Поскольку на каждом шаге алгоритм выбирает наименьшее значение из трех возможных операций (вставка, удаление, замена),
  он гарантированно находит минимальное количество операций, необходимых для преобразования одной строки в другую.
*/

func main() {
	input := getInputData()
	s := input[0]
	t := input[1]

	fmt.Println(LevenshteinDistance(s, t))
}

func LevenshteinDistance(s, t string) int {
	n, m := len(s), len(t)

	dp := make([][]int, n+1)
	for i := range dp {
		dp[i] = make([]int, m+1)
	}

	for i := 0; i <= n; i++ {
		dp[i][0] = i
	}
	for j := 0; j <= m; j++ {
		dp[0][j] = j
	}

	for i := 1; i <= n; i++ {
		for j := 1; j <= m; j++ {
			if s[i-1] == t[j-1] {
				dp[i][j] = dp[i-1][j-1]
			} else {
				dp[i][j] = 1 + minOperation(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])
			}
		}
	}

	// Расстояние Левенштейна для всей строки s и t находится в правом нижнем углу массива dp.
	return dp[n][m]
}

func minOperation(a, b, c int) int {
	minVal := a
	if b < minVal {
		minVal = b
	}
	if c < minVal {
		minVal = c
	}
	return minVal
}

func getInputData() []string {
	input, _ := os.Open("input.txt")
	defer input.Close()

	const maxCapacity = 10240 * 1024
	buf := make([]byte, maxCapacity)

	scanner := bufio.NewScanner(input)
	scanner.Split(bufio.ScanLines)
	scanner.Buffer(buf, maxCapacity)

	var s []string
	for scanner.Scan() {
		bufStr := scanner.Text()
		s = append(s, bufStr)
	}

	return s
}
